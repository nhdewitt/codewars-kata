"""
Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.

Examples:

interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
interleave([]) == []

https://www.codewars.com/kata/523d2e964680d1f749000135/train/python
"""

from itertools import zip_longest, chain

def interleave(*args):
    zipped = list(zip_longest(*args))                       # zip_longest to include arrays of shorter length
    return list(chain.from_iterable(map(list, zipped)))     # chain.from_iterable to flatten the resulting mapped list